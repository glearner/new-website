{
    "title": [
        "What new features added to ES2020?"
    ],
    "link": [
        "https://medium.com/@gkverma1094/what-new-features-added-to-es2020-7e7d4d70184e?source=rss-445df3ce30f2------2"
    ],
    "guid": [
        {
            "_": "https://medium.com/p/7e7d4d70184e",
            "$": {
                "isPermaLink": "false"
            }
        }
    ],
    "category": [
        "software-development",
        "javascript",
        "react",
        "es2020",
        "node"
    ],
    "dc:creator": [
        "Gaurav K. Verma"
    ],
    "pubDate": [
        "Sat, 11 Apr 2020 23:57:24 GMT"
    ],
    "atom:updated": [
        "2020-04-12T00:04:47.096Z"
    ],
    "content:encoded": [
        "<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*_1yUVJY6cDvLNc0ISUKPbQ.png\" /></figure><p>So, it has been a while ES20 features around us, but we are not using it. Some of us know about them but some may not. So, I’m just giving you the basic idea about new features which is going to make your life easier as a developer. So, let’s begin.</p><h3>Dynamic Import</h3><p>This is my most favorites feature in all of them. So, dynamic Import introduces a new function-like form of import that unlocks new capabilities compared to static import. Dynamic Import introduces a new function-like form of import that caters to those use cases.</p><pre>&lt;script type=&quot;module&quot;&gt;<br>  const moduleSpecifier = &#39;./utils.mjs&#39;;<br>  import(moduleSpecifier)<br>    .then((module) =&gt; {<br>      module.default();<br>      // → logs &#39;Hi from the default export!&#39;<br>      module.doStuff();<br>      // → logs &#39;Doing stuff…&#39;<br>    });<br>&lt;/script&gt;</pre><p>Since import() returns a promise, it’s possible to use async/await instead of the then-based callback style:</p><pre>&lt;script type=&quot;module&quot;&gt;<br>  (async () =&gt; {<br>    const moduleSpecifier = &#39;./utils.mjs&#39;;<br>    const module = await import(moduleSpecifier)<br>    module.default();<br>    // → logs &#39;Hi from the default export!&#39;<br>    module.doStuff();<br>    // → logs &#39;Doing stuff…&#39;<br>  })();<br>&lt;/script&gt;</pre><p>FYI, import() <em>looks</em> like a function call, it is specified as <em>syntax</em> that just happens to use parentheses (similar to super()).</p><h3>Nullish coalescing</h3><p>As we all know, sometimes we need to handle null and undefined conditions separately, but in general, how we do that is demoed below</p><pre>const enable = props.enabled || true; <br>//if props.enabled undefined, it will take true as its value</pre><p>Now, there’s an issue, props.enabled will assign true even if props.enabled is false or 0 but here, we only want to handle only null and undefined, then we have manually check typeof or we do another check but nullish coalescing (??) will solve this issue very easily.</p><pre>false ?? true;   // =&gt; false<br>0 ?? 1;          // =&gt; 0<br>&#39;&#39; ?? &#39;default&#39;; // =&gt; &#39;&#39;</pre><pre>null ?? [];      // =&gt; []<br>undefined ?? []; // =&gt; []</pre><h3><strong>Promise combinators</strong></h3><p>Promise combinators like <strong>Promise.all</strong> and <strong>Promise.race</strong>. But now, we got 2 new more static methodsPromise.allSettled and Promise.any .With those additions, there’ll be a total of four promise combinators in JavaScript, each enabling different use cases.Promise.allSettled gives you a signal when all the input promises are <em>settled</em>, which means they’re either <em>fulfilled</em> or <em>rejected</em>. This is useful in cases where you don’t care about the state of the promise, you just want to know when the work is done, regardless of whether it was successful.</p><pre>const promises = [<br>  fetch(&#39;/api-call-1&#39;),<br>  fetch(&#39;/api-call-2&#39;),<br>  fetch(&#39;/api-call-3&#39;),<br>];<br>// Imagine some of these requests fail, and some succeed.</pre><pre>await Promise.allSettled(promises);<br>// All API calls have finished (either failed or succeeded).<br>removeLoadingIndicator();</pre><p>Promise.any gives you a signal as soon as one of the promises fulfills. This is similar to Promise.race, except any doesn’t reject early when one of the promises rejects.</p><pre>const promises = [<br>  fetch(&#39;/endpoint-a&#39;).then(() =&gt; &#39;a&#39;),<br>  fetch(&#39;/endpoint-b&#39;).then(() =&gt; &#39;b&#39;),<br>  fetch(&#39;/endpoint-c&#39;).then(() =&gt; &#39;c&#39;),<br>];<br>try {<br>  const first = await Promise.any(promises);<br>  // Any of the promises was fulfilled.<br>  console.log(first);<br>  // → e.g. &#39;b&#39;<br>} catch (error) {<br>  // All of the promises were rejected.<br>  console.log(error);<br>}</pre><h3>String.matchAll</h3><p>For me, it is very common to repeatedly apply the same regular expression on a string to get all the matches. To some extent, this is already possible today by using the String#match method. Something like this.</p><pre>const string = &#39;Magic hex numbers: DEADBEEF CAFE&#39;;<br>const regex = /\\b\\p{ASCII_Hex_Digit}+\\b/gu;<br>for (const match of string.match(regex)) {<br>  console.log(match);<br>}</pre><pre>// Output:<br>// &#39;DEADBEEF&#39;<br>// &#39;CAFE&#39;</pre><p>However, this only gives you the <em>substrings</em> that match. Usually, you don’t just want the substrings, you also want additional information such as the index of each substring, or the capturing groups within each match.</p><p>It’s already possible to achieve this by writing your own loop, and keeping track of the match objects yourself, but it’s a little annoying and not very convenient:</p><pre>const string = &#39;Magic hex numbers: DEADBEEF CAFE&#39;;<br>const regex = /\\b\\p{ASCII_Hex_Digit}+\\b/gu;<br>let match;<br>while (match = regex.exec(string)) {<br>  console.log(match);<br>}</pre><pre>// Output:<br>// [ &#39;DEADBEEF&#39;, index: 19, input: &#39;Magic hex numbers: DEADBEEF CAFE&#39; ]<br>// [ &#39;CAFE&#39;,     index: 28, input: &#39;Magic hex numbers: DEADBEEF CAFE&#39; ]</pre><p>But now, new String#matchAll API makes this easier than ever before: you can now write a simple for-of loop to get all the match objects.</p><pre>const string = &#39;Magic hex numbers: DEADBEEF CAFE&#39;;<br>const regex = /\\b\\p{ASCII_Hex_Digit}+\\b/gu;<br>for (const match of string.matchAll(regex)) {<br>  console.log(match);<br>}</pre><pre>// Output:<br>// [ &#39;DEADBEEF&#39;, index: 19, input: &#39;Magic hex numbers: DEADBEEF CAFE&#39; ]<br>// [ &#39;CAFE&#39;,     index: 28, input: &#39;Magic hex numbers: DEADBEEF CAFE&#39; ]</pre><p>String#matchAll is especially useful for regular expressions with capture groups.</p><h3>globalThis</h3><p>If I’ve written JavaScript for use in a web browser before, I have used window to access the global this. In Node.js, I have used global. If you’ve written code that must work in either environment, you may have detected which of these is available, and then used that — but the list of identifiers to check grows with the number of environments and use cases you want to support.</p><p>Some of my naive attempt to get ‘this’. Please don’t judge me.</p><pre>const getGlobalThis = () =&gt; {<br>  if (typeof globalThis !== &#39;undefined&#39;) return globalThis;<br>  if (typeof self !== &#39;undefined&#39;) return self;<br>  if (typeof window !== &#39;undefined&#39;) return window;<br>  if (typeof global !== &#39;undefined&#39;) return global;<br>  // Note: this might still return the wrong result!<br>  if (typeof this !== &#39;undefined&#39;) return this;<br>  throw new Error(&#39;Unable to locate global `this`&#39;);<br>};<br>const theGlobalThis = getGlobalThis();</pre><p>The globalThis proposal introduces a <em>unified</em> mechanism to access the global this in any JavaScript environment (browser, Node.js, or something else?), regardless of the script goal (classic script or module?).</p><p>And now that ugly code can be written in one line of code.</p><pre>const theGlobalThis = globalThis;</pre><p>First, I looked at this, it looks like magic to me.</p><h3>Optional chaining</h3><p>We all know, long chains of property accesses in JavaScript can be error-prone, as any of them might evaluate to null or undefined (also known as “nullish” values). Checking for property existence on each step easily turns into a deeply-nested structure of if-statements or a long if-condition replicating the property access chain:</p><pre>// Error prone-version, could throw.<br>const nameLength = db.user.name.length;</pre><pre>// Less error-prone, but harder to read.<br>let nameLength;<br>if (db &amp;&amp; db.user &amp;&amp; db.user.name)<br>  nameLength = db.user.name.length;</pre><p>The above can also be expressed using the ternary operator, which doesn’t exactly help readability:</p><pre>const nameLength =<br>  (db<br>    ? (db.user<br>      ? (db.user.name<br>        ? db.user.name.length<br>        : undefined)<br>      : undefined)<br>    : undefined);</pre><p>But now, optional chaining comes for us to rescue. The above ugly code can be written as:</p><pre>const nameLength = db?.user?.name?.length;</pre><p>For me, its lifesaver, like checking a method exist in nested object and then executing it. Like:</p><pre>const adminOption = db?.user?.validate?.()</pre><p>Here, we can execute validate once validate exist and not undefined.</p><h3>BigInt: arbitrary-precision integers</h3><p>Finally, we got bigInt in javascript. BigIntis a new primitive in the JavaScript language.BigInt is a new numeric primitive in JavaScript that can represent integers with arbitrary precision. With BigInts, you can safely store and operate on large integers even beyond the safe integer limit for Numbers. This article walks through some use cases and explains the new functionality in Chrome 67 by comparing BigInts to Numbers in JavaScript.</p><p>BigInts make it possible to correctly perform integer arithmetic without overflowing. Example:</p><pre>const max = Number.MAX_SAFE_INTEGER;<br>// → 9_007_199_254_740_991</pre><p>So, what’s the issue. Let see what happen when we add 1 and 2</p><pre>max + 1;<br>// → 9_007_199_254_740_992 (correct)</pre><pre>max + 2;<br>// → 9_007_199_254_740_992 (false)</pre><p>So now BigInt is here to save us:</p><pre>BigInt(Number.MAX_SAFE_INTEGER) + 2n;<br>// → 9_007_199_254_740_993n (correct)</pre><pre>Don&#39;t try to multiply like this<br>1234567890123456789 * 123;<br>// → 151851850485185200000 (wrong)</pre><pre>1234567890123456789n * 123n;<br>// → 151851850485185185047n (correct)</pre><p>The safe integer limits for Numbers don’t apply to BigInts. Therefore,with BigInt we can perform correct integer arithmetic without having to worry about losing precision.</p><h3>Module namespace exports</h3><p>Last but not least, we use the default exports to export only a single value. During import, we can omit the curly braces, and we can use the name that we want:</p><pre>//------ utils.js ------<br>export default 10;<br>//------ main.js ------<br>import aValue from &#39;utils.mjs&#39;;//------ utils.js ------<br>export default class MyClass {}<br>//------ main.js ------<br>import oneClass from &#39;utils.mjs&#39;;</pre><p>But now we can also do something like this:</p><pre>//------ utils.js ------<br><strong>export * as utils from &#39;./utils.mjs&#39;</strong></pre><p>Namespace exports introduce the same usage style for import/export keywords to the developer, obtaining symmetrical behavior, and helping to avoid errors.</p><p>That’s all, now you know more about Javascript and its new features which made you a better coder than before.</p><p>If you want to support me, please give claps to my blog and follow me,</p><p><strong>“Lets code better”</strong></p><img src=\"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=7e7d4d70184e\" width=\"1\" height=\"1\" alt=\"\">"
    ]
}