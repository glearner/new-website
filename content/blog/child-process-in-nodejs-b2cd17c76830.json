{
    "title": [
        "Child Process in Nodejs"
    ],
    "link": [
        "https://medium.com/@gkverma1094/child-process-in-nodejs-b2cd17c76830?source=rss-445df3ce30f2------2"
    ],
    "guid": [
        {
            "_": "https://medium.com/p/b2cd17c76830",
            "$": {
                "isPermaLink": "false"
            }
        }
    ],
    "category": [
        "v8",
        "nodejs",
        "bash",
        "javascript",
        "nodejs-development"
    ],
    "dc:creator": [
        "Gaurav K. Verma"
    ],
    "pubDate": [
        "Sun, 17 May 2020 19:51:12 GMT"
    ],
    "atom:updated": [
        "2020-05-17T20:03:53.408Z"
    ],
    "content:encoded": [
        "<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*zS_WaV3gt7sl88loHHxYqw.jpeg\" /></figure><p>I have been working on nodejs for a long time. Since we all know Nodejs is not made for heavy server-side calculations. Node.js processes IOs in a non-blocking way, meaning that its single thread can manage several IO requests at the same time.</p><p>But sometimes we have to do some heavy calculations on the server-side, since nodejs is single-threaded, we can’t block the main thread for these kinds of calculations.</p><p>For these kinds of computations, we need to use the inbuilt library called<strong><em> child_process. </em></strong>Let&#39;s see why?</p><p>Child_process opens a process by creating a pipe, forking, and invoking the shell. Since a pipe is by definition unidirectional, the <em>type</em> argument may specify only reading or writing, not both the resulting stream is correspondingly read-only or write-only.</p><p>In simple words, <strong>child_process</strong> enable you for doing heavy computation by creating native OS or kernel threads. So, you can execute any script which that system (where you running your node script) supports.</p><p>I’m going to discuss some of the main methods from these libraries which save you from a lot of hell.</p><h3>child_process.spawn</h3><p>The child_process.spawn() method spawns the child process asynchronously, without blocking the Node.js event loop. The child_process.spawnSync() function provides equivalent functionality in a synchronous manner that blocks the event loop until the spawned process either exits or is terminated.</p><p>Let’s take an example</p><pre>const { spawn } = require(&quot;child_process&quot;);</pre><pre>const ls = spawn(&quot;cat&quot;, [&quot;index.js&quot;]);</pre><pre>ls.stdout.on(&quot;data&quot;, (data) =&gt; {<br>console.log(`stdout: ${data}`);<br>});</pre><pre>ls.stderr.on(&quot;data&quot;, (data) =&gt; {<br>console.error(`stderr: ${data}`);<br>});</pre><pre>ls.on(&quot;close&quot;, (code) =&gt; {<br>console.log(`child process exited with code ${code}`);<br>});</pre><p>Here, if we save above code as index.js, we get an output as</p><pre>&gt;&gt; node index.js </pre><pre>stdout: const { spawn } = require(&quot;child_process&quot;);<br>const ls = spawn(&quot;cat&quot;, [&quot;index.js&quot;]);</pre><pre>ls.stdout.on(&quot;data&quot;, (data) =&gt; {<br>  console.log(`stdout: ${data}`);<br>});</pre><pre>ls.stderr.on(&quot;data&quot;, (data) =&gt; {<br>  console.error(`stderr: ${data}`);<br>});</pre><pre>ls.on(&quot;close&quot;, (code) =&gt; {<br>  console.log(`child process exited with code ${code}`);<br>});</pre><p>We are here just running a shell command inside nodejs (shell-command because I&#39;m running the script on my Linux machine).</p><h3>child_process.exec</h3><p>`child_process.exec() spawns a shell and runs a command within that shell, passing the stdout and stderr to a callback function when complete. It spawns a shell then executes the command within that shell, buffering any generated output.</p><p>Let’s see an example</p><pre>const { exec } = require(&#39;child_process&#39;);<br>exec(&#39;python run.py&#39;, (err, stdout, stderr) =&gt; {<br>  if (err) {<br>    console.error(err);<br>    return;<br>  }<br>  console.log(stdout);<br>});</pre><pre>//output v12.16.3</pre><p>Here, with the help of the exec method, you can run any script just passing the command as a first parameter, and second as a callback so we can get the output from that file.</p><h3>child_process.execFile</h3><p>The child_process.execFile() is similar to child_process.exec() except that it does not spawn a shell by default. Rather, the specified executable file is spawned directly as a new process making it slightly more efficient than child_process.exec().</p><p>Let’s see an example</p><pre>const { execFile } = require(&#39;child_process&#39;);<br>const child = execFile(&#39;node&#39;, [&#39;--version&#39;], (error, stdout, stderr) =&gt; {<br>  if (error) {<br>    throw error;<br>  }<br>  console.log(stdout);<br>});<br>//output<br>v12.16.3</pre><h3>child_process.fork</h3><p>The child_process.fork() method is a special case of child_process.spawn() used specifically to spawn new Node.js processes. Like child_process.spawn(), a ChildProcess object is returned. The returned ChildProcess will have an additional communication channel built-in that allows messages to be passed back and forth between the parent and child. See subprocess.send() for details.</p><p>By default, child_process.fork() will spawn new Node.js instances using the process.execPath of the parent process. The execPath property in the options object allows for an alternative execution path to be used.</p><pre>//index.js</pre><pre>const { fork } = require(&quot;child_process&quot;);<br>const ls = fork(&quot;./child.js&quot;);</pre><pre>let count = 0;</pre><pre>//exiting the thread when child process ended</pre><pre>ls.on(&quot;exit&quot;, (code) =&gt; {<br>console.log(`child_process exited with code ${code}`);<br>});</pre><pre>ls.on(&quot;message&quot;, (msg) =&gt; {<br>console.log(`PARENT: message from child process is ${msg}`);<br>count = parseInt(msg) + 1;<br>console.log(&quot;PARENT: +1 from parent&quot;);<br>ls.send(count);<br>});</pre><pre>//child.js<br>var count = Math.floor(Math.random() * 100);</pre><pre>process.on(&quot;message&quot;, (msg) =&gt; {<br>console.log(&quot;CHILD: message received from parent process&quot;, msg);</pre><pre>count = parseInt(msg) + 1;</pre><pre>console.log(&quot;CHILD: +1 from child&quot;);<br>if (count &lt;= 100) process.send(count);<br>else process.exit(1);<br>});</pre><pre>console.log(count);</pre><pre>process.send(count);</pre><p>Well, this code simply passing messages back and forth between child process and its parent. The output will be something like this:</p><pre>&gt;&gt; node index.js<br>89<br>PARENT: message from child process is 89<br>PARENT: +1 from parent<br>CHILD: message received from parent process 90<br>CHILD: +1 from child<br>PARENT: message from child process is 91<br>PARENT: +1 from parent<br>CHILD: message received from parent process 92<br>CHILD: +1 from child<br>PARENT: message from child process is 93<br>PARENT: +1 from parent<br>CHILD: message received from parent process 94<br>CHILD: +1 from child<br>PARENT: message from child process is 95<br>PARENT: +1 from parent<br>CHILD: message received from parent process 96<br>CHILD: +1 from child<br>PARENT: message from child process is 97<br>PARENT: +1 from parent<br>CHILD: message received from parent process 98<br>CHILD: +1 from child<br>PARENT: message from child process is 99<br>PARENT: +1 from parent<br>CHILD: message received from parent process 100<br>CHILD: +1 from child<br>child_process exited with code 1</pre><p>I tried to explain as simple as I can. But if you found anything missing just reach out to me in comments.</p><p>If you want to support me, please give claps to my blog and follow me,</p><p><strong>“Lets code better”</strong></p><img src=\"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=b2cd17c76830\" width=\"1\" height=\"1\" alt=\"\">"
    ]
}